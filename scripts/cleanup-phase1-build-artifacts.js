#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

console.log('🧹 CLEANUP PHASE 1: Removing Build Artifacts & Generated Files');

// Phase 1A: Remove all dist directories
console.log('\n📦 Removing dist directories...');
let distRemoved = 0;

const findAndRemoveDistDirs = (dir) => {
  try {
    const items = fs.readdirSync(dir);

    items.forEach(item => {
      const fullPath = path.join(dir, item);
      const stat = fs.statSync(fullPath);

      if (stat.isDirectory()) {
        if (item === 'dist') {
          console.log(`    📦 Removing: ${path.relative(process.cwd(), fullPath)}`);
          fs.rmSync(fullPath, { recursive: true, force: true });
          distRemoved++;
        } else if (item !== 'node_modules') {
          // Recursively check subdirectories but skip node_modules for now
          findAndRemoveDistDirs(fullPath);
        }
      }
    });
  } catch (error) {
    // Skip directories we can't read
  }
};

findAndRemoveDistDirs('./packages');

// Phase 1B: Remove source map files
console.log('\n🗺️  Removing source map files...');
let sourceMapsRemoved = 0;

const removeSourceMaps = (dir) => {
  try {
    const items = fs.readdirSync(dir);

    items.forEach(item => {
      const fullPath = path.join(dir, item);
      const stat = fs.statSync(fullPath);

      if (stat.isFile() && (item.endsWith('.js.map') || item.endsWith('.css.map'))) {
        fs.unlinkSync(fullPath);
        sourceMapsRemoved++;
        if (sourceMapsRemoved <= 10) { // Show first 10 for feedback
          console.log(`    🗺️  Removed: ${path.basename(item)}`);
        }
      } else if (stat.isDirectory() && item !== 'node_modules') {
        removeSourceMaps(fullPath);
      }
    });
  } catch (error) {
    // Skip directories we can't read
  }
};

removeSourceMaps('./packages');

// Phase 1C: Remove auto-generated declaration files in build directories
console.log('\n📄 Removing auto-generated declaration files...');
let declarationFilesRemoved = 0;

const removeGeneratedDeclarations = (dir) => {
  try {
    const items = fs.readdirSync(dir);

    items.forEach(item => {
      const fullPath = path.join(dir, item);
      const stat = fs.statSync(fullPath);

      if (stat.isFile() && item.endsWith('.d.ts')) {
        // Only remove .d.ts files that are clearly auto-generated
        const content = fs.readFileSync(fullPath, 'utf8');
        if (content.includes('Generated by') ||
            content.includes('Auto-generated') ||
            content.includes('This file was automatically generated') ||
            content.length < 50) { // Very short declaration files are likely auto-generated
          fs.unlinkSync(fullPath);
          declarationFilesRemoved++;
          if (declarationFilesRemoved <= 10) {
            console.log(`    📄 Removed: ${path.basename(item)}`);
          }
        }
      } else if (stat.isDirectory() && item !== 'node_modules' && item !== 'src') {
        removeGeneratedDeclarations(fullPath);
      }
    });
  } catch (error) {
    // Skip directories we can't read
  }
};

removeGeneratedDeclarations('./packages');

// Phase 1D: Remove temporary build files
console.log('\n🗄️  Removing temporary build files...');
let tempFilesRemoved = 0;

const tempPatterns = [
  '.cache',
  '.tmp',
  '.temp',
  'tsconfig.tsbuildinfo',
  '.turbo',
  '.next',
  '.nuxt',
  'coverage'
];

const removeTempFiles = (dir) => {
  try {
    const items = fs.readdirSync(dir);

    items.forEach(item => {
      const fullPath = path.join(dir, item);
      const stat = fs.statSync(fullPath);

      if (stat.isDirectory()) {
        if (tempPatterns.includes(item)) {
          console.log(`    🗄️  Removing: ${path.relative(process.cwd(), fullPath)}`);
          fs.rmSync(fullPath, { recursive: true, force: true });
          tempFilesRemoved++;
        } else if (item !== 'node_modules') {
          removeTempFiles(fullPath);
        }
      } else if (stat.isFile()) {
        if (tempPatterns.some(pattern => item.includes(pattern)) ||
            item.endsWith('.log') ||
            item.endsWith('.tmp') ||
            item.endsWith('.swp')) {
          fs.unlinkSync(fullPath);
          tempFilesRemoved++;
          console.log(`    🗄️  Removed: ${path.basename(item)}`);
        }
      }
    });
  } catch (error) {
    // Skip directories we can't read
  }
};

removeTempFiles('./packages');

// Phase 1E: Remove lock files in subdirectories (keep only root level)
console.log('\n🔒 Removing redundant lock files...');
let lockFilesRemoved = 0;

const removeLockFiles = (dir, depth = 0) => {
  try {
    const items = fs.readdirSync(dir);

    items.forEach(item => {
      const fullPath = path.join(dir, item);
      const stat = fs.statSync(fullPath);

      if (stat.isFile() && depth > 1) { // Only remove lock files in subdirectories
        if (item === 'package-lock.json' ||
            item === 'yarn.lock' ||
            item === 'pnpm-lock.yaml') {
          fs.unlinkSync(fullPath);
          lockFilesRemoved++;
          console.log(`    🔒 Removed: ${path.relative(process.cwd(), fullPath)}`);
        }
      } else if (stat.isDirectory() && item !== 'node_modules') {
        removeLockFiles(fullPath, depth + 1);
      }
    });
  } catch (error) {
    // Skip directories we can't read
  }
};

removeLockFiles('./packages');

console.log('\n✅ Phase 1 Complete:');
console.log(`    📦 ${distRemoved} dist directories removed`);
console.log(`    🗺️  ${sourceMapsRemoved} source map files removed`);
console.log(`    📄 ${declarationFilesRemoved} auto-generated declaration files removed`);
console.log(`    🗄️  ${tempFilesRemoved} temporary files/directories removed`);
console.log(`    🔒 ${lockFilesRemoved} redundant lock files removed`);

const totalRemoved = distRemoved + sourceMapsRemoved + declarationFilesRemoved + tempFilesRemoved + lockFilesRemoved;
console.log(`\n📊 Total build artifacts removed: ${totalRemoved}`);
console.log('🎯 Expected impact: Significant reduction in file count and duplication rate');