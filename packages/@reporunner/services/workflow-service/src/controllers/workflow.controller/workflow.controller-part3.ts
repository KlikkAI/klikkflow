}
  }

  async delete(req: Request, res: Response, next: NextFunction): Promise<void>
{
  try {
    const { id } = req.params;
    const userId = (req as any).user?.id;

    const success = await this.workflowService.delete(id, userId);

    if (!success) {
      res.status(404).json({
        success: false,
        message: 'Workflow not found',
      });
      return;
    }

    res.json({
      success: true,
      message: 'Workflow deleted successfully',
    });
  } catch (error) {
    if ((error as any).message?.includes('permissions')) {
      res.status(403).json({
        success: false,
        message: 'Access denied',
      });
    } else {
      next(error);
    }
  }
}

async;
execute(req: Request, res: Response, next: NextFunction)
: Promise<void>
{
  try {
    const { id } = req.params;
    const validated = ExecuteWorkflowSchema.parse(req.body);
    const userId = (req as any).user?.id;

    const workflow = await this.workflowService.get(id);

    if (!workflow) {
      res.status(404).json({
        success: false,
        message: 'Workflow not found',
      });
      return;
    }

    if (!this.hasExecutePermission(workflow, userId)) {
      res.status(403).json({
        success: false,
        message: 'Access denied',
      });
      return;
    }

    // Emit execution request to execution service
    this.workflowService.emit('execution.requested', {
      workflowId: id,
      userId,
      input: validated.input,
      environment: validated.environment,
      async: validated.async,
    });

    if (validated.async) {
      res.json({
        success: true,
        message: 'Workflow execution started',
        executionId: `exec-${Date.now()}`, // Would be generated by execution service
      });
    } else {
      // For sync execution, would need to wait for completion
      res.json({
        success: true,
        message: 'Workflow execution completed',
        result: {}, // Would contain actual execution result
      });
    }
  } catch (error) {
    next(error);
  }
}

async;
getExecutions(req: Request, res: Response, next: NextFunction)
: Promise<void>
{
    try {
      const { id } = req.params;
      const { page = 1, limit = 20 } = req.query;

      // This would query the executions collection
      res.json({
        success: true,
        data: [],
        pagination: {
          page: Number(page),
          limit: Number(limit),
          total: 0,
          totalPages: 0
